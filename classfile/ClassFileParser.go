package classfile

import "fmt"

const (
	JAVA_CLASSFILE_MAGIC = 0xCAFEBABE

	JAVA_MIN_SUPPORTED_VERSION = 45
	JAVA_MAX_SUPPORTED_VERSION = 53

	JAVA_5_VERSION = 49
	JAVA_6_VERSION = 50
	JAVA_7_VERSION = 51
	JAVA_8_VERSION = 51
	JAVA_9_VERSION = 53

	//access flag
	JVM_ACC_PUBLIC       = 0x0001 /* visible to everyone */
	JVM_ACC_PRIVATE      = 0x0002 /* visible only to the defining class */
	JVM_ACC_PROTECTED    = 0x0004 /* visible to subclasses */
	JVM_ACC_STATIC       = 0x0008 /* instance variable is static */
	JVM_ACC_FINAL        = 0x0010 /* no further subclassing, overriding */
	JVM_ACC_SYNCHRONIZED = 0x0020 /* wrap method call in monitor lock */
	JVM_ACC_SUPER        = 0x0020 /* funky handling of invokespecial */
	JVM_ACC_VOLATILE     = 0x0040 /* can not cache in registers */
	JVM_ACC_BRIDGE       = 0x0040 /* bridge method generated by compiler */
	JVM_ACC_TRANSIENT    = 0x0080 /* not persistent */
	JVM_ACC_VARARGS      = 0x0080 /* method declared with variable number of args */
	JVM_ACC_NATIVE       = 0x0100 /* implemented in C */
	JVM_ACC_INTERFACE    = 0x0200 /* class is an interface */
	JVM_ACC_ABSTRACT     = 0x0400 /* no definition provided */
	JVM_ACC_STRICT       = 0x0800 /* strict floating point */
	JVM_ACC_SYNTHETIC    = 0x1000 /* compiler-generated class, method or field */
	JVM_ACC_ANNOTATION   = 0x2000 /* annotation type */
	JVM_ACC_ENUM         = 0x4000 /* field is declared as element of enum */
)

func Parse(data []byte) *ClassFile {
	classFile := ClassFile{}
	classFileReader := ClassFileReader{data}
	parseMagic(&classFile, &classFileReader)
	parseVersion(&classFileReader, &classFile)
	parseConstantPool(&classFileReader, &classFile)
	parseAccessFlag(&classFileReader, &classFile)
	return &classFile
}

func parseMagic(classFile *ClassFile, classFileReader *ClassFileReader) {
	classFile.magic = classFileReader.ReadUint32()
	if classFile.magic != JAVA_CLASSFILE_MAGIC {
		panic("Illegal class file format")
	}
}

func parseVersion(classFileReader *ClassFileReader, classFile *ClassFile) {
	minorVersion := classFileReader.ReadUint16()
	majorVersion := classFileReader.ReadUint16()
	classFile.minorVersion = minorVersion
	classFile.majorVersion = majorVersion
}

func parseConstantPool(classFileReader *ClassFileReader, classFile *ClassFile) {
	constantPoolCount := int(classFileReader.ReadUint16())
	if constantPoolCount <= 1 {
		panic("Illegal constant pool size " + string(constantPoolCount) + " .")
	}
	constantInfoList := make([]ConstantInfoReader, constantPoolCount)
	for i := 1; i < constantPoolCount; i++ {
		constantInfo := getConstantInfoByTag(classFileReader)
		constantInfo.ReadInfo(classFileReader, classFile)
		constantInfoList[i] = constantInfo
	}
	fmt.Println(constantInfoList)
}

func parseAccessFlag(reader *ClassFileReader, classFile *ClassFile) {
	access_flags := reader.ReadUint16()
	classFile.accessFlags = access_flags
	if has_illegal_visibility(access_flags) {
		panic("Illegal visibility of class")
	}
}

func has_illegal_visibility(accessFlag uint16) bool {
	is_public := (accessFlag & JVM_ACC_PUBLIC) != 0
	is_protected := (accessFlag & JVM_ACC_PROTECTED) != 0
	is_private := (accessFlag & JVM_ACC_PRIVATE) != 0
	return (is_public && is_protected) ||
		(is_public && is_private) ||
		(is_protected && is_private)
}

func getConstantInfoByTag(classFileReader *ClassFileReader) ConstantInfoReader {
	tag := classFileReader.ReadUint8()
	switch tag {
	case JVM_CONSTANT_Utf8:
		return &ConstantUtf8Info{}
	case JVM_CONSTANT_Integer:
		return &ConstantIntegerInfo{}
	case JVM_CONSTANT_Float:
		return &ConstantFloatInfo{}
	case JVM_CONSTANT_Long:
		return &ConstantLongInfo{}
	case JVM_CONSTANT_Double:
		return &ConstantDoubleInfo{}
	case JVM_CONSTANT_Class:
		return &ConstantClassInfo{}
	case JVM_CONSTANT_String:
		return &ConstantStringInfo{}
	case JVM_CONSTANT_Fieldref:
		return &ConstantMemberRefInfo{}
	case JVM_CONSTANT_Methodref:
		return &ConstantMemberRefInfo{}
	case JVM_CONSTANT_InterfaceMethodref:
		return &ConstantMemberRefInfo{}
	case JVM_CONSTANT_NameAndType:
		return &ConstantNameAndTypeIndex{}
	case JVM_CONSTANT_MethodHandle: //todo
	case JVM_CONSTANT_MethodType: //todo
	case JVM_CONSTANT_InvokeDynamic: //todo
	}
	panic("java.lang.ClassFormatError: unknown constant pool tag ")
}
